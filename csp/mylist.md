201803-4 棋局评估

**关键词：博弈论最大值最小值算法**，对抗搜索 

<https://blog.csdn.net/xbb224007/article/details/79935167>

1. Alice 为正分，Bob 为负分：所以如果是 Alice 下，她会使自己得到的分数最大。Bob 使自己得到的分数最大，负分表示就是最小。
2. 使用 DFS 枚举所有的情况：
   - 如果当前步是 Alice 下，那么遍历Alice能下的所有位置，返回结果中最终局面的最大值
   - 如果是 Bob 下，遍历 Bob 能下的所有位置，返回结果中最终局面的最小值。
3. 判断是否有人获胜





# 201712-3 Crontab

转载链接： <https://blog.csdn.net/banana_cjb/article/details/79174688>



思路：

  (1）根据每个时间，判断能执行哪条命令；

（2）根据每个命令，判断其运行时间，将其存储在vector中，然后对vector排序并输出。

前者行不通。

时间使用 long long 存储。

参考博文的解决方案：

1. 由于同一时刻可能对应多条命令，并且此时要按照输入顺序输出，而不是命令的字母表顺序。所以不可以使用map，而只能用**vector<pair<LL, int> >**来存储“时间 序号”对，然后输出时把序号换成对应的命令。

2. 首先根据minute项，得到符合条件的minutes，将其存储在**set（假设为set0）**中（为了保证无重复）；下一步根据hour项，得到符合条件的hours，此时对每个hour与set0中的每个minute组合，可以得到无重复的，符合条件的“hourMinutes”，存储在**set1**中。组合的方式很简单，hour*100+minute即可。以此类推，可以得出第五个项分析完毕时，符合条件的时间也就正式构造完毕了。

3. 考虑到各个项的组成部分相似，所以可以把对单个项处理的部分抽离开，写成一个函数，循环调用它。并且创建一个**vector<set<LL> >以保存每次产生的set**。那么这里会出现几个问题：（1）处理minute，month等的细节是稍有不同的，所以我们需要同时传参数以表明我们当前正在处理哪个项；（2）产生不合法时间（例如2月30号）怎么办。为了不增加编码复杂度，我们可以在初期不进行时间检查，直到第五个项（星期）时统一检查，**主要检查当前日期是否合法，以及当前时间是否在系统开机范围内**。其实星期这一项，就是在选择年份，因为在月、日确定的时候，一个年对应一个day of week。所以我们把最后的时间检查放在这里是完全合理的。

4. 先星号（全部符合），再逗号（分成不同的小区间处理），然后减号（确定区间两端数字），最后英文缩写。分清楚之后实现就比较简单了，不过需要注意如下几个点：（1）**如果是星号，要注意minute，hour，week从0开始，而day和month是从1开始的**；（2）分析逗号的时候，一定要注意最后一个逗号后面还有一个区间，别忘了分析；（3）需要自己写一个**字符串转数字**的函数，把字符串形式的数字与英文缩写转化为数字。

   

​     一般而言，模拟题的关键在于**数据表示**，有了正确合理的数据表示，基本上就成功了。

  编程采用自顶向下逐步细化的结构化编程思想。这样使得程序的每一个局部逻辑都变得简单易懂。

比如月份和日期的简写，有可能是**不规范**

  程序中，尽可能把功能通用化，并且封装到函数中。





**201703-4 地铁修建**



1. **最小生成树+并查集**

一直添加到起点和终点连通后，最后添加的边的大小就是答案，判断是否有回路，使用并查集 // 2. 最小生成树，直接按照最小生成树做，当1和n 连通时就找到答案了，因为这时候肯定是边最小的。

2. 套用Dijkstra，只不过将松弛操作改为边尽量短（把判断距离改成判断 最大路权即可），顺带记录路径最后再扫一遍找出路径中的最长边。 





我不太理解，  为什么最小生成树是对的，最小生成树使得所有的边加起来最小，但是并不保证最长边最小啊，而且这道题并不要求每个结点都加入，不是会有 2-3-10，4-10 的情况吗。按照最小生成树会选择第一种，但是第二种才是最短啊。注意看题！地铁可以同时施工啊！找出最后的路径，确定最长的那一条边就好了！

所以用Kruskal算法，先把边集按从小到大的顺利排序，之后每次加入还未使用过的且不会形成回路的最短边，一直添加到起点和终点连通后，最后添加的边的大小就是答案。



<https://blog.csdn.net/nameofcsdn/article/details/69372138>

<https://blog.csdn.net/qq_16234613/article/details/76795271> 最小生成树的

<https://blog.csdn.net/more_ugly_less_bug/article/details/75676355>

<https://blog.csdn.net/Rewriter_huanying/article/details/77387563>！  这个比较好！

