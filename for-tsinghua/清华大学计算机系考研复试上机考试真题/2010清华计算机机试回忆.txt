一、特殊乘法，123 * 45 = 1*4 +1*5 +2*4 +2*5 +3*4+3*5
      写个算法，对2个小于1000000000的输入，求结果
二、数的分解：任何数都能分解成2的幂，比如
  7=1+1+1+1+1+1+1
    =1+1+1+1+1+2
    =1+1+1+2+2
    =1+2+2+2
    =1+1+1+4
    =1+2+4
共有6种分解方式，设f(n)为任意正整数可能分解总数，比如f(7)=6
写个算法，输入数，大于10000000000的按除以10000000000所得余数计算，求结果

三、N<k时，root(N,k) = N，否则，root(N,k) = root(N',k). N'为N的k进制表示的各位数字之和
输入x,y,k，输出root(x^y,k)的值 (这里^为乘方，不是异或)，2=<k<=16，0<x,y<2000000000,
有一半的测试点里 x^y 会溢出int的范围(>=2000000000)

题目只是大概回忆一下，可能不太准确，另外上机的输入和输出都不是从文件，都是从控制台输入输出，每考完一题就将源程序的单个文件提交到指定网站，总共可以提交50次，以随后提交的结果为准。

感谢confuciusli纠正第三题的部分错误

[ 本帖最后由 modpro 于 2010-3-25 16:18 编辑 ]


题目如下：

一个整数总可以拆分为2的幂的和，例如：
7=1+2+4
7=1+2+2+2
7=1+1+1+4
7=1+1+1+2+2
7=1+1+1+1+1+2
7=1+1+1+1+1+1+1
总共有六种不同的拆分方式。
用f(n)表示n的不同拆分的种数，例如f(7)=6.
要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000.

先给出代码：

#include <stdio.h>
int f[1000001];
int main ()
{
    int i, n;
    scanf("%d", &n);
    f[0] = f[1] = 1;
    for (i=2; i<=n; ++i) {
        if (i % 2)
            f [  i] = f[i-1];
        else
            f [  i] = (f[i-1] + f[i/2]) % 1000000000;
    }
    printf ("%d\n", f[n]);
    return 0;
}

当然，还可以优化，比如f的长度和循环次数都可以减半，这里略去。

思路如下：
对于奇数n=2k+1：它的拆分的第一项一定是1，考虑去掉这个1，其实就一一对应于
2k的拆分，因此f(2k+1)=f(2k).

对于偶数n=2k：考虑有1和没有1的拆分。有1的拆分，与(2k-1)的拆分一一对应，与上面奇数的情况
理由相同；没有1的拆分，将每项除以2，正好一一对应于k的所有拆分。因此f(2k)=f(2k-1)+f(k).

需要注意f(n)会很大，不要溢出了。最终结果只要求除以十亿的余数，在int的表示范围内，
因此不需要大数运算。注意余数的性质：(a+b)%m == (a%m+b%m)%m，所以只要对每个中间
结果也都取余数，就不会有溢出的问题，且不改变最终输出结果。