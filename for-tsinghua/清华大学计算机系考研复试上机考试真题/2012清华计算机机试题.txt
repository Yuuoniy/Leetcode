本人做的很差，就不提供解答了，等着诸位大牛们来提供题解吧。若题目有什么错误的话，也麻烦大家指正。
第一题：求最大最小数

   先输入N,表示数的个数，然后输入N个数，求这N个数的最大值和最小值。N<=10000，输入的数的绝对值不大于10^6

样例输入：4  
              2 0 1 2
样例输出：    2  0

第二题：密码锁

    玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=<N<=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。（表述不准确，不知道说清楚了没有，欢迎指正）
   第一行输入N，第二行输入N个数字，只包含0，1，2

样例输入：5
             02120
样例输出：1

第三题：函数求值

   给定正整数N，函数F(N)表示小于等于N的自然数中1和2的个数之和，例如：1,2,3,4,5,6,7,8,9,10序列中1和2的个数之和为3，因此 F(10)=3
输入N，求F(N)的值，1=<N<=10^100(10的100次方)若F(N)很大，则求F(N)mod20123的值（我记得是20123，如有错误欢迎指正）


样例输入：10

样例输出：3


   大概就是这样吧。另外今年不让带纸质资料，提交后只能显示“编译通过”或者“编译不通过”，看不到AC,WA,TLE,MLE之类的状态。不过带资料也没用，因为基本都是数学题，我练了半天的算法基本上都没用上，最后只能靠暴力刷case了，估计结果很悲剧。希望能有学上。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

题目推荐肥猫同学的，堪称完美回忆版，题目细节都记录得无比清晰。考研有这样的对手让人肝儿颤啊( ⊙ o ⊙ )！
http://www.cskaoyan.com/thread-85509-1-1.html
我的解答不一定是最好的，抛砖引玉吧。
第一题就略了。
第二题：这道题n非常小n≤13，可以用很暴力的按变换次数做广度优先搜索，3^13=1594323所以可以把每一个串看成一个三进制的数，这样hash到一个int里。空间也不会超。
压缩后，判断是否有子串2012可以这样：（三进制的2012=十进制的59）
while（x>=59）
{
    if( (x-59)%81==0)
        return 成功；
  else
        x/=3;
}
return 失败；

每一位3种状态，最多3^13=10^6种状态。每种状态判断是否包括2012这个子串，如上的方法也只用比较10次。
实际上，如果可以移位成功，移位的次数是很少的，足够在规定的时间里算出答案。



第三题是有点暴力的动态规划。
预处理三个数组，c中保存以下这些段中1和2的个数。
0-9：2个
00-99：20*2个
000-999:200*3个
。。。
pow10保存10的次幂。
num保存第i+1个字符到第n个字符所表示的数字的值%20123
以345123为例说明怎么计算。
先把0-34123分成0-29999和30000-34123两部分，后一部分实际上被化归为前一个问题了，即求0-4123中1和2出现的次数。
现在问题转化为怎样求第一部分：
它包括两种，一种是首位提供的1或2.从10000-19999和20000-29999，共2*pow10[4]个。
另外还有非首位提供的1和2，即k组0000-9999，共k*c[4]个。
总共2*pow10[4]+k*c[4]

当k=1时，首位提供的,就不能用c数组算了，而是要用num数组。为num+1
当k=2时，同理，首位提供的为pow10[l-1]+num+1


附代码：

第二题：
#include <stdlib.h>
#include <stdio.h>
#include <bitset> 
#include <string.h>
using namespace std;
bool checksub(int x)
{
        while(x>=59) 
        {
                if((x-59)%81==0) 
                        return true;
                else x/=3;
        }
        return false;
}

int getInput(int &n)
{
        int tmp,i;
    char s[14];//保存输入
    scanf("%s",s);
    n=strlen(s);
    tmp=0;//将输入转化成十进制 
    for(i=0;i<n;i++)
    {
                tmp*=3;
                tmp+=s[i]-'0';
        }        
        return tmp;
}
int bfs(int tmp,int n)
{
    int tmps0[1000],tmps1[1000];//保存每次广度优先遍历的值,滚动数组 
        int tIndexNow,tIndexNext,changeCount,x,j,i; 
        int pow3[13]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441};
        int change[9]={0,2,4,-2,0,2,-4,-2,0};//保存三进制的00-00,01-10,02-20,10-01,11-11,...的值 
        bitset< 1594323 > v;
        tIndexNow=0,tIndexNext=0;//初始化广度优先遍历
        tmps0[tIndexNext++]=tmp;        
        changeCount=0;tIndexNow=tIndexNext;tIndexNext=0;
        if(checksub(tmp)) return 0;
        v[tmp]=1;
        while(tIndexNow!=0)
        {
                for(j=0;j<tIndexNow;j++)//对每个状态计算其未访问到的下一个状态 
                {
                        if((changeCount&1)==0) 
                                x=tmps0[j];
                        else
                                x=tmps1[j]; 
                        for(i=0;i<n-1;i++)//每个状态有n-1种交换方法 
                        {
                                tmp=x+change[x/pow3[i]%9]*pow3[i];
                                if(!v[tmp])//该节点未访问过
                                {
                                        if(checksub(tmp)) //判断是否含2012
                                                return changeCount+1; 
                                        v[tmp]=1;
                                        if((changeCount&1)==0) 
                                                tmps1[tIndexNext++]=tmp;
                                        else
                                                tmps0[tIndexNext++]=tmp;                                        
                                }
                        }
                } 
                changeCount++;tIndexNow=tIndexNext;tIndexNext=0;
        }
        return -1;
} 
int main()
{
        int tmp,ans,n;
        while(1)
        {
                tmp=getInput(n);
                ans=bfs(tmp,n);                
                printf("%d\n",ans);
        }
        return 0; 
}
复制代码
第三题：
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int main()
{
        char s[102];
        int c[102],pow10[102],num[102];
        int n,i,tmp,j,sum,tmpsum,l,k;
        scanf("%s",s);
        n=strlen(s);
        c[0]=0;
        c[1]=2;
        for(i=2;i<n;i++)
                c[i]=c[i-1]*10%20123;
        for(i=2;i<n;i++)
                c[i]=c[i]*i%20123;
        pow10[0]=1;
        for(i=1;i<n;i++)
                pow10[i]=pow10[i-1]*10%20123;
        for(i=0;i<n;i++)
                if(s[i]=='1' || s[i]=='2')
                {
                        tmp=0;
                        for(j=i+1;j<n;j++)
                        {
                                tmp*=10;
                                tmp+=s[j]-'0';
                        }
                        num[i]=tmp;
                }
        sum=0;
        for(i=0;i<n;i++)
        {
                tmpsum=0;
                l=n-i;
                k=s[i]-'0';
                if(k>2) tmpsum=k*c[l-1]+2*pow10[l-1];
                else if(k==0) tmpsum=0;
                else if(k==1) tmpsum=c[l-1]+num[i]+1;
                else if(k==2) tmpsum=2*c[l-1]+pow10[l-1]+num[i]+1;
                sum+=tmpsum;
                sum%=20123;                
        }
        printf("%d\n",sum);
        return 0;
}
复制代码