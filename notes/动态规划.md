# 动态规划算法

C++ STL 求向量中的最大值和最小值min_element(v.begin(),v.end()) max_element(v.begin(),v.end()) 

例：*min_element(triangle.back().begin(), triangle.back().end());

## 区间 DP

区间DP，顾名思义是在区间上DP，它的主要思想就是先在小区间进行DP得到最优解，然后再利用小区间的最优解合并求大区间的最优解。



```C++
//mst(dp,0) 初始化DP数组
for(int i=1;i<=n;i++)
{
    dp[i][i]=初始值
}
for(int len=2;len<=n;len++)  //区间长度
for(int i=1;i<=n;i++)        //枚举起点
{
    int j=i+len-1;           //区间终点
    if(j>n) break;           //越界结束
    for(int k=i;k<j;k++)     //枚举分割点，构造状态转移方程
    {
        dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);
    }

}
```



### 最长上升子序列



### 最长公共子序列



### 数字三角形

F\[i]\[j] 表示从

**triangle\[i][j] = min(triangle\[i - 1][j - 1], triangle\[i - 1][j]) **

我们从第二行开始更新，注意两边的数字直接赋值上一行的边界值，那么最终我们只要在最底层找出值最小的数字，就是全局最小的路径和

### 编辑距离

<http://www.cnblogs.com/pandora/archive/2009/12/20/levenshtein_distance.html>



使用dp[i][j]用来表示字符串1的0~i-1、字符串2的0~j-1的最小编辑距离；
我们可以知道边界情况：dp\[i][0] = i、dp\[0][j]=j；
同时对于两个字符串的子串，都能分为最后一个字符相等或者不等的情况：
如果words[i-1] == words[j-1]：dp\[i][j] = dp\[i-1][j-1]；也就是说当前的编辑距离和位置i和j的字符无关；
如果words[i-1] != words[j-1]：则存在三种可能的操作： 
向word1插入：dp\[i][j] = dp\[i][j-1] + 1;
从word1删除：dp\[i][j] = dp\[i-1][j] + 1;

替换word1元素：dp\[i][j] = dp\[i-1][j-1] + 1;



接着对于不相同的时候我们的情况比较复杂，我们有三种处理手段，分别是insert、replace和remove。我们先看insert操作。我们insert完之后，也就是word1中的元素会保持不变，而j会向前挪一个位置，也就是f(i,j)=f(i,j−1)+1 f(i,j)=f(i,j-1)+1f(i,j)=f(i,j−1)+1。接着考虑replace操作，replace会减少word1和word2中一个需要比较的元素（i和j会向前挪一个位置），也就是f(i,j)=f(i−1,j−1)+1 f(i,j)=f(i-1,j-1)+1f(i,j)=f(i−1,j−1)+1。我们接着考虑最后一个remove操作，这个就很容易了，word1中会减少一个需要比较的元素，而我们j的位置不变，也就是f(i,j)=f(i−1,j)+1 f(i,j)=f(i-1,j)+1f(i,j)=f(i−1,j)+1。所以我们最后的结果相当三者取最小值即可。



### 最长回文子串

我们维护一个二维数组 dp，其中 dp[i][j] 表示字符串区间 [i, j] 是否为回文串，当 i = j 时，只有一个字符，肯定是回文串，如果 i = j + 1，说明是相邻字符，此时需要判断 s[i] 是否等于 s[j]，如果i和j不相邻，即 i - j >= 2 时，除了判断 s[i] 和 s[j] 相等之外，dp[j + 1][i - 1] 若为真，就是回文串，通过以上分析，可以写出递推式如下：

dp[i, j] = 1                                               if i == j

​           = s[i] == s[j]                                if j = i + 1

​           = s[i] == s[j] && dp[i + 1][j - 1]    if j > i + 1      

这里有个有趣的现象就是如果我把下面的代码中的二维数组由 int 改为 vector<vector<int>> 后，就会超时，这说明 int 型的二维数组访问执行速度完爆 std 的 vector 啊，所以以后尽可能的还是用最原始的数据类型吧。

### 正则表达式匹配





### 最大正方形

 dp\[i][j] 表示到达 (i, j) 位置所能组成的最大正方形的边长。我们首先来考虑边界情况，也就是当i或j为0的情况，那么在首行或者首列中，必定有一个方向长度为1，那么就无法组成长度超过1的正方形，最多能组成长度为1的正方形，条件是当前位置为1。边界条件处理完了，再来看一般情况的递推公式怎么办，对于任意一点 dp\[i][j]，由于该点是正方形的右下角，所以该点的右边，下边，右下边都不用考虑，关心的就是左边，上边，和左上边。这三个位置的dp值 suppose 都应该算好的，还有就是要知道一点，只有当前 (i, j) 位置为1，dp\[i][j] 才有可能大于0，否则 dp\[i][j] 一定为0。当 (i, j) 位置为1，此时要看 dp\[i-1][j-1], dp\[i][j-1]，和 dp\[i-1][j] 这三个位置，我们找其中最小的值，并加上1，就是 dp\[i][j] 的当前值了，这个并不难想，毕竟不能有0存在，所以只能取交集，最后再用 dp\[i][j] 的值来更新结果 res 的值即可





感叹号!表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号!!的作用就是看a和b是否为正整数



### 最长有效括号

  

1. 状态：
   **DP[i]：以s[i-1]为结尾的longest valid parentheses substring的长度。**

2. 通项公式：
   s[i] = '('：
   DP[i] = 0

s[i] = ')'：找i前一个字符的最长括号串DP[i]的前一个字符**j = i-2-DP[i-1]**
**DP[i] = DP[i-1] + 2 + DP[j]，如果j >=0，且s[j] = '('**
**DP[i] = 0，如果j<0，或s[j] = ')'**

......... (     x    x    x    x   )
          j                      i-2 i-1

显然**自左向右，且DP[0] = 0**

## 状态压缩

涉及到集合问题，使用状态压缩。

遍历每个状态。

1<< N ; 状态数目。

i&(1<<(j)) 如果为1，表示当前状态包含 j。我们需要考虑当前状态的迁移状态是什么，然后写出状态转移方程。

dp 数组可以使用结构体呀