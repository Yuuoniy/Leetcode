# 总结

## 入门模拟

### 日期类问题

### 排版题





## 算法初步

### 散列



### 贪心

### 二分

#### 快速幂

### Hash





### two pointers



### 深度优先搜索

深度优先搜索从最开始的状态出发，遍历所有可以到达的状态。

### 宽度优先搜索

按照距开始状态由近及远的顺序进行搜索，很容易用来

```c++


bfs(s) {
  q = new queue()
  q.push(s)), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}
```



深度优先搜索使用栈进行计算，而宽度优先则利用了队列。搜索时首先将初始状态添加到队列里，此后从队列的最前端不断取出状态，把从该状态可以转移到的状态中尚未访问过的部分加入队列，如此往复，**直至队列为空或找到解。**

## 数学问题

### 

### 最大公约数和最小公倍数

### 分数的四则运算

### 素数

### 质因子分解

### 大整数运算

### 进制转换



## 数据结构

### 栈

典型应用：

- 括号匹配
- 简单计算器

### 哈夫曼树

### 二叉树

### 二叉搜索树





## 树



### 并查集

#### 路径压缩



## 图论

### 图存储

### 图遍历



### 最短路

#### Dijkstra 算法

解决单源最短路问题。

```C++
初始化
for(循环 n 次){
	u = 使 d[u] 最小的还未被访问的顶点的标号
	记 u已被访问；
    for(从 u 出发能到达的所有顶点v){
    	if(v 未被访问&&以u为中介点使s到顶点v的最短距离 d[v]更优){
    	优化 d[v];
    	令 v 的前驱为 v//用来输出最短路径
 }
```

最短路径：



出题：

- 

#### Dijkstra + DFS



#### **Dijkstra + 优先队列(小顶堆)**



#### BF算法和SPFA

##### BF

求解有负权边的最短路。会多次访问曾经访问过的顶点。

```c++
for(int i=0;i<n-1;i++){
    for(each each u->v){
        if(d[u]+length[u->v]<d[v]){
            d[v] = d[u]+length[u->v]
        }
    }
}
```

判断是否有从源点可达的负环：

```c++
for(each each u->v){
    if(d[u]+length[u->v]<d[v]){
        return false;
    }
}
```

使用邻接表。

##### SPFA:

BF 的时间复杂度为O(VE),每轮操作都要操作所有的边，影响了性能。注意到，

**只有当某个顶点 u  的 d[u]值改变时，从它出发的边的邻接点v 的d[v]值才有可能被改变。**

**优化：**

建立一个优先队列，每次将队首顶点u取出，然后对从 u 出发的所有边 u->v 进行松弛操作，即判断 d[u]+length[u->v] < d[v] 是否成立，如果成立，则更新 d[v]，并且如果 v 不在队列中，则加入队列，一直操作直到队列为空，说明图中没有从源点可达的负环。或是某个顶点的入队的次数超过 V-1，说明图中存在从源点可达的负环。

```c++
queue<int> Q;
源点 s 入队
while(队列非空){
	取出队首的元素 u；
    for(u的所有邻接边 u->v){
    if(d[u]+dis<d[v]){
    	d[v] = d[u]+dis;
    	if(v不在队列中){
    	v 入队；
        if(v入队的次数大于 n-1){
        说明有可达负环，return;
        }
    }
}
```

SPFA 的期望复杂度为 O(kE),E 是图的边数，k是一个常数，很多情况下不超过2，但如果有源点可达的负环，则会退化成O(VE)

#### Floyd算法

最短路求解差分约束

### 最小生成树

### 拓扑排序



## 搜索

查找：

- 查找空间
- 查找目标
- 查找方法



## 动态规划

